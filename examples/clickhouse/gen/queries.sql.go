// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"strings"
)

const analyzeArrayElements = `-- name: AnalyzeArrayElements :many
SELECT 
	product_id,
	arrayJoin(categories) AS category,
	COUNT(*) OVER (PARTITION BY category) as category_count
FROM sqlc_example.products
WHERE product_id = ?
GROUP BY product_id, category;
`

type AnalyzeArrayElementsRow struct {
	Column1       interface{}
	Category      interface{}
	CategoryCount interface{}
}

func (q *Queries) AnalyzeArrayElements(ctx context.Context, dollar_1 interface{}) ([]AnalyzeArrayElementsRow, error) {
	rows, err := q.db.Query(ctx, analyzeArrayElements, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyzeArrayElementsRow
	for rows.Next() {
		var i AnalyzeArrayElementsRow
		if err := rows.Scan(&i.Column1, &i.Category, &i.CategoryCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const extractMetadataFromJSON = `-- name: ExtractMetadataFromJSON :many
SELECT 
	MetadataPlatformId,
	arrayJoin(JSONExtract(JsonValue, 'Array(String)')) as self_help_id
FROM sqlc_example.events;
`

type ExtractMetadataFromJSONRow struct {
	Column1    interface{}
	SelfHelpID interface{}
}

func (q *Queries) ExtractMetadataFromJSON(ctx context.Context) ([]ExtractMetadataFromJSONRow, error) {
	rows, err := q.db.Query(ctx, extractMetadataFromJSON)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractMetadataFromJSONRow
	for rows.Next() {
		var i ExtractMetadataFromJSONRow
		if err := rows.Scan(&i.Column1, &i.SelfHelpID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterUsersByIDAndStatus = `-- name: FilterUsersByIDAndStatus :many
SELECT id, name, email, status, created_at
FROM sqlc_example.users
WHERE id IN ($1)
AND status IN ('active', 'pending')
ORDER BY created_at DESC;

`

type FilterUsersByIDAndStatusRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
}

// ORDER BY with WITH FILL for time series
func (q *Queries) FilterUsersByIDAndStatus(ctx context.Context, userIds []interface{}) ([]FilterUsersByIDAndStatusRow, error) {
	rows, err := q.db.Query(ctx, filterUsersByIDAndStatus, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterUsersByIDAndStatusRow
	for rows.Next() {
		var i FilterUsersByIDAndStatusRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
			&i.Column5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastedValues = `-- name: GetCastedValues :many
SELECT 
	id::String as id_text,
	amount::Float32 as amount_float,
	created_at::Date as date_only,
	status::String as status_text
FROM sqlc_example.events
WHERE created_at::Date >= $1;

`

type GetCastedValuesRow struct {
	IDText      interface{}
	AmountFloat interface{}
	DateOnly    interface{}
	StatusText  interface{}
}

// ARRAY JOIN examples
func (q *Queries) GetCastedValues(ctx context.Context, dateFilter interface{}) ([]GetCastedValuesRow, error) {
	rows, err := q.db.Query(ctx, getCastedValues, dateFilter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCastedValuesRow
	for rows.Next() {
		var i GetCastedValuesRow
		if err := rows.Scan(
			&i.IDText,
			&i.AmountFloat,
			&i.DateOnly,
			&i.StatusText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentAnalytics = `-- name: GetCommentAnalytics :many
SELECT 
	p.id as post_id,
	p.title,
	COUNT(*) as total_comments,
	uniqExact(c.user_id) as unique_commenters,
	countIf(c.created_at >= toDate(now()) - 7) as comments_last_week,
	argMin(c.created_at, c.id) as first_comment_time,
	argMax(c.created_at, c.id) as last_comment_time
FROM sqlc_example.posts p
LEFT JOIN sqlc_example.comments c ON p.id = c.post_id
WHERE p.user_id = $1
GROUP BY p.id, p.title
ORDER BY total_comments DESC;

`

type GetCommentAnalyticsRow struct {
	PostID           interface{}
	Column2          interface{}
	TotalComments    interface{}
	UniqueCommenters interface{}
	CommentsLastWeek interface{}
	FirstCommentTime interface{}
	LastCommentTime  interface{}
}

// Statistical aggregate functions
func (q *Queries) GetCommentAnalytics(ctx context.Context, userID interface{}) ([]GetCommentAnalyticsRow, error) {
	rows, err := q.db.Query(ctx, getCommentAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentAnalyticsRow
	for rows.Next() {
		var i GetCommentAnalyticsRow
		if err := rows.Scan(
			&i.PostID,
			&i.Column2,
			&i.TotalComments,
			&i.UniqueCommenters,
			&i.CommentsLastWeek,
			&i.FirstCommentTime,
			&i.LastCommentTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsForPost = `-- name: GetCommentsForPost :many
SELECT id, post_id, user_id, content, created_at
FROM sqlc_example.comments
WHERE post_id = $1
ORDER BY created_at ASC;
`

type GetCommentsForPostRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
}

func (q *Queries) GetCommentsForPost(ctx context.Context, postID interface{}) ([]GetCommentsForPostRow, error) {
	rows, err := q.db.Query(ctx, getCommentsForPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsForPostRow
	for rows.Next() {
		var i GetCommentsForPostRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
			&i.Column5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsStatistics = `-- name: GetMetricsStatistics :many
SELECT 
	category,
	COUNT(*) as count,
	varSamp(value) as variance_sample,
	varPop(value) as variance_population,
	stddevSamp(value) as stddev_sample,
	stddevPop(value) as stddev_population,
	corr(value_x, value_y) as correlation
FROM sqlc_example.metrics
WHERE timestamp >= $1 AND timestamp <= $2
GROUP BY category
ORDER BY count DESC;

`

type GetMetricsStatisticsParams struct {
	StartTime interface{}
	EndTime   interface{}
}

type GetMetricsStatisticsRow struct {
	Column1            interface{}
	Count              interface{}
	VarianceSample     interface{}
	VariancePopulation interface{}
	StddevSample       interface{}
	StddevPopulation   interface{}
	Correlation        interface{}
}

// Conditional aggregate variants
func (q *Queries) GetMetricsStatistics(ctx context.Context, arg GetMetricsStatisticsParams) ([]GetMetricsStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getMetricsStatistics, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMetricsStatisticsRow
	for rows.Next() {
		var i GetMetricsStatisticsRow
		if err := rows.Scan(
			&i.Column1,
			&i.Count,
			&i.VarianceSample,
			&i.VariancePopulation,
			&i.StddevSample,
			&i.StddevPopulation,
			&i.Correlation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderMetrics = `-- name: GetOrderMetrics :many
SELECT 
	status,
	COUNT(*) as total_orders,
	minIf(amount, amount > 0) as min_positive_amount,
	maxIf(amount, amount > 0) as max_positive_amount,
	sumIf(amount, status = 'completed') as completed_revenue,
	avgIf(rating, rating IS NOT NULL) as avg_valid_rating
FROM sqlc_example.orders
WHERE created_at >= $1
GROUP BY status
ORDER BY total_orders DESC;

`

type GetOrderMetricsRow struct {
	Column1           interface{}
	TotalOrders       interface{}
	MinPositiveAmount interface{}
	MaxPositiveAmount interface{}
	CompletedRevenue  interface{}
	AvgValidRating    interface{}
}

// IN operator with multiple conditions
func (q *Queries) GetOrderMetrics(ctx context.Context, startDate interface{}) ([]GetOrderMetricsRow, error) {
	rows, err := q.db.Query(ctx, getOrderMetrics, startDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderMetricsRow
	for rows.Next() {
		var i GetOrderMetricsRow
		if err := rows.Scan(
			&i.Column1,
			&i.TotalOrders,
			&i.MinPositiveAmount,
			&i.MaxPositiveAmount,
			&i.CompletedRevenue,
			&i.AvgValidRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByOptionalStatus = `-- name: GetPostsByOptionalStatus :many
SELECT id, user_id, title, status, created_at
FROM sqlc_example.posts
WHERE ($1 IS NULL OR status = $1)
ORDER BY created_at DESC;

`

type GetPostsByOptionalStatusRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
}

// ClickHouse-specific aggregate functions
func (q *Queries) GetPostsByOptionalStatus(ctx context.Context, status interface{}) ([]GetPostsByOptionalStatusRow, error) {
	rows, err := q.db.Query(ctx, getPostsByOptionalStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsByOptionalStatusRow
	for rows.Next() {
		var i GetPostsByOptionalStatusRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
			&i.Column5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSeriesWithFill = `-- name: GetTimeSeriesWithFill :many
SELECT date, metric_value
FROM sqlc_example.timeseries
WHERE date >= $1 AND date <= $2
ORDER BY date WITH FILL FROM sqlc.arg('start_date') TO sqlc.arg('end_date');

`

type GetTimeSeriesWithFillParams struct {
	StartDate interface{}
	EndDate   interface{}
}

type GetTimeSeriesWithFillRow struct {
	Column1 interface{}
	Column2 interface{}
}

// Type casting examples
func (q *Queries) GetTimeSeriesWithFill(ctx context.Context, arg GetTimeSeriesWithFillParams) ([]GetTimeSeriesWithFillRow, error) {
	rows, err := q.db.Query(ctx, getTimeSeriesWithFill, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeSeriesWithFillRow
	for rows.Next() {
		var i GetTimeSeriesWithFillRow
		if err := rows.Scan(&i.Column1, &i.Column2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnalytics = `-- name: GetUserAnalytics :many
SELECT 
	u.id,
	u.name,
	COUNT(*) as total_posts,
	uniqExact(p.id) as unique_posts,
	countIf(p.created_at >= toDate(now()) - 30) as posts_last_30_days,
	argMax(p.title, p.created_at) as latest_post_title,
	argMaxIf(p.title, p.created_at, p.created_at >= toDate(now()) - 30) as latest_post_in_30_days
FROM sqlc_example.users u
LEFT JOIN sqlc_example.posts p ON u.id = p.user_id
GROUP BY u.id, u.name
HAVING COUNT(*) > 0
ORDER BY total_posts DESC;
`

type GetUserAnalyticsRow struct {
	Column1            interface{}
	Column2            interface{}
	TotalPosts         interface{}
	UniquePosts        interface{}
	PostsLast30Days    interface{}
	LatestPostTitle    interface{}
	LatestPostIn30Days interface{}
}

func (q *Queries) GetUserAnalytics(ctx context.Context) ([]GetUserAnalyticsRow, error) {
	rows, err := q.db.Query(ctx, getUserAnalytics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAnalyticsRow
	for rows.Next() {
		var i GetUserAnalyticsRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.TotalPosts,
			&i.UniquePosts,
			&i.PostsLast30Days,
			&i.LatestPostTitle,
			&i.LatestPostIn30Days,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, created_at
FROM sqlc_example.users
WHERE email = $1;
`

type GetUserByEmailRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

func (q *Queries) GetUserByEmail(ctx context.Context, email interface{}) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.Column1,
		&i.Column2,
		&i.Column3,
		&i.Column4,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, created_at
FROM sqlc_example.users
WHERE id = ?;
`

type GetUserByIDRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

func (q *Queries) GetUserByID(ctx context.Context, dollar_1 interface{}) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, dollar_1)
	var i GetUserByIDRow
	err := row.Scan(
		&i.Column1,
		&i.Column2,
		&i.Column3,
		&i.Column4,
	)
	return i, err
}

const getUserPostsForUser = `-- name: GetUserPostsForUser :many
SELECT p.id, p.user_id, p.title, p.content, p.created_at
FROM sqlc_example.posts p
WHERE p.user_id = $1
ORDER BY p.created_at DESC;
`

type GetUserPostsForUserRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
}

func (q *Queries) GetUserPostsForUser(ctx context.Context, userID interface{}) ([]GetUserPostsForUserRow, error) {
	rows, err := q.db.Query(ctx, getUserPostsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPostsForUserRow
	for rows.Next() {
		var i GetUserPostsForUserRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
			&i.Column5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPosts = `-- name: GetUserWithPosts :many
SELECT u.id, u.name, u.email, u.created_at, p.id as post_id, p.title
FROM sqlc_example.users u
LEFT JOIN sqlc_example.posts p ON u.id = p.user_id
WHERE u.id = $1
ORDER BY p.created_at DESC;

`

type GetUserWithPostsRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	PostID  interface{}
	Column6 interface{}
}

// Named parameter with nullable values using sqlc.narg()
func (q *Queries) GetUserWithPosts(ctx context.Context, userID interface{}) ([]GetUserWithPostsRow, error) {
	rows, err := q.db.Query(ctx, getUserWithPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWithPostsRow
	for rows.Next() {
		var i GetUserWithPostsRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
			&i.PostID,
			&i.Column6,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertComment = `-- name: InsertComment :exec
INSERT INTO sqlc_example.comments (id, post_id, user_id, content, created_at)
VALUES (?, ?, ?, ?, ?);
`

type InsertCommentParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
}

func (q *Queries) InsertComment(ctx context.Context, arg InsertCommentParams) error {
	err := q.db.Exec(ctx, insertComment,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const insertPost = `-- name: InsertPost :exec
INSERT INTO sqlc_example.posts (id, user_id, title, content, created_at)
VALUES ($1, $2, $3, $4, $5);
`

type InsertPostParams struct {
	ID        interface{}
	UserID    interface{}
	Title     interface{}
	Content   interface{}
	CreatedAt interface{}
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) error {
	err := q.db.Exec(ctx, insertPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Content,
		arg.CreatedAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO sqlc_example.users (id, name, email, created_at)
VALUES (?, ?, ?, ?);

`

type InsertUserParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

// Named parameter examples using sqlc.arg() function
func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	err := q.db.Exec(ctx, insertUser,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	return err
}

const insertUserNamed = `-- name: InsertUserNamed :exec
INSERT INTO sqlc_example.users (id, name, email, created_at)
VALUES ($1, $2, $3, $4);
`

type InsertUserNamedParams struct {
	ID        interface{}
	Name      interface{}
	Email     interface{}
	CreatedAt interface{}
}

func (q *Queries) InsertUserNamed(ctx context.Context, arg InsertUserNamedParams) error {
	err := q.db.Exec(ctx, insertUserNamed,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.CreatedAt,
	)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, created_at
FROM sqlc_example.users
ORDER BY created_at DESC
LIMIT ?;
`

type ListUsersRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

func (q *Queries) ListUsers(ctx context.Context, limit interface{}) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfoldEventProperties = `-- name: UnfoldEventProperties :many
SELECT 
	e.event_id,
	e.event_name,
	e.timestamp,
	prop_key,
	prop_value
FROM sqlc_example.events_with_properties e
ARRAY JOIN e.properties.keys AS prop_key, e.properties.values AS prop_value
WHERE e.timestamp >= $1
ORDER BY e.timestamp DESC;
`

type UnfoldEventPropertiesRow struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
	Column5 interface{}
}

func (q *Queries) UnfoldEventProperties(ctx context.Context, startTime interface{}) ([]UnfoldEventPropertiesRow, error) {
	rows, err := q.db.Query(ctx, unfoldEventProperties, startTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnfoldEventPropertiesRow
	for rows.Next() {
		var i UnfoldEventPropertiesRow
		if err := rows.Scan(
			&i.Column1,
			&i.Column2,
			&i.Column3,
			&i.Column4,
			&i.Column5,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfoldNestedData = `-- name: UnfoldNestedData :many
SELECT 
	record_id,
	nested_value
FROM sqlc_example.nested_table
ARRAY JOIN nested_array AS nested_value
WHERE record_id IN ($1);
`

type UnfoldNestedDataRow struct {
	Column1 interface{}
	Column2 interface{}
}

func (q *Queries) UnfoldNestedData(ctx context.Context, recordIds []interface{}) ([]UnfoldNestedDataRow, error) {
	rows, err := q.db.Query(ctx, unfoldNestedData, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnfoldNestedDataRow
	for rows.Next() {
		var i UnfoldNestedDataRow
		if err := rows.Scan(&i.Column1, &i.Column2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfoldUserTags = `-- name: UnfoldUserTags :many
SELECT 
	u.id as user_id,
	u.name as user_name,
	tag
FROM sqlc_example.users_with_tags u
ARRAY JOIN u.tags AS tag
WHERE u.id = $1
ORDER BY tag;
`

type UnfoldUserTagsRow struct {
	UserID   interface{}
	UserName interface{}
	Column3  interface{}
}

func (q *Queries) UnfoldUserTags(ctx context.Context, userID interface{}) ([]UnfoldUserTagsRow, error) {
	rows, err := q.db.Query(ctx, unfoldUserTags, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnfoldUserTagsRow
	for rows.Next() {
		var i UnfoldUserTagsRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.Column3); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
